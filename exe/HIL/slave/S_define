/************************TRICK HEADER*************************
PURPOSE:
    (Lists out the other object files that are not included from C++ headers)
LIBRARY DEPENDENCIES:
(
)
*************************************************************/

#include "sim_objects/default_trick_sys.sm"

##include "Time_management.hh"

##include "Ins.hh"
##include "Control.hh"
##include "GPS.hh"
##include "cad_utility.hh"
##include "datadeck.hh"
##include "time_utility.hh"
##include "math_utility.hh"
##include "integrate.hh"
##include "stochastic.hh"
##include "matrix/utility.hh"
##include "global_constants.hh"
##include "transceiver.hh"
##include  "icf_trx_ctrl.h"

class FlightComputer_SimObject : public Trick::SimObject {
    public:

        double ltg_thrust, no_thrust, clear_gps;

        INS ins;

        Control control;

        time_management *time = time_management::get_instance();

        Transceiver transceiver;

        GPS_FSW gps;
        struct icf_ctrlblk_t   icf_esps_ctrl;

        void setup_export(){
            transceiver.register_for_transmit(EXPORT(control, get_theta_a_cmd));
            transceiver.register_for_transmit(EXPORT(control, get_theta_b_cmd));
            transceiver.register_for_transmit(EXPORT(control, get_theta_c_cmd));
            transceiver.register_for_transmit(EXPORT(control, get_theta_d_cmd));

            /* XXX */
            transceiver.register_for_transmit("ins", "clear_gps_flag", [this](){ return this->clear_gps; });
            transceiver.register_for_transmit("guidance", "no_thrust", [this](){ return this->no_thrust; });
            transceiver.register_for_transmit("guidance", "ltg_thrust", [this](){ return this->ltg_thrust; });
        };

        void link(){
            control.grab_dvbec = LINK(ins, get_dvbec);
            control.grab_thtvdcx = LINK(ins, get_thtvdcx);
            control.grab_thtbdcx = LINK(ins, get_thtbdcx);
            control.grab_phibdcx = LINK(ins, get_phibdcx);
            control.grab_psibdcx = LINK(ins, get_psibdcx);
            control.grab_TBDQ = LINK(ins, get_TBDQ);
            control.grab_TBD = LINK(ins, get_TBD);
            control.grab_alphacx = LINK(ins, get_alphacx);
            control.grab_TBICI = LINK(ins, get_TBICI);
            control.grab_TBIC = LINK(ins, get_TBIC);

            gps.grab_SBIIC = LINK(ins, get_SBIIC);
            gps.grab_VBIIC = LINK(ins, get_VBIIC);
            gps.grab_WBICI = LINK(ins, get_WBICI);
            gps.grab_SBEEC = LINK(ins, get_SBEEC);
            gps.grab_VBEEC = LINK(ins, get_VBEEC);
            gps.grab_TEIC = LINK(ins, get_TEIC);

            ins.grab_SXH                    = LINK(gps           , get_SXH);
            ins.grab_VXH                    = LINK(gps           , get_VXH);
            

            /* remote */
            // control.grab_mprop              = transceiver(IMPORT(propulsion     , get_mprop));
            // control.grab_dvbe               = transceiver(IMPORT(dynamics       , get_dvbe));
            // control.grab_pdynmc             = transceiver(IMPORT(environment    , get_pdynmc));
            // control.grab_qqcx               = transceiver(IMPORT(*gyro          , get_qqcx));
            // control.grab_rrcx               = transceiver(IMPORT(*gryo          , get_rrcx));
            control.grab_FSPCB              = transceiver(IMPORT(*accelerometer , get_computed_FSPB));
            control.grab_computed_WBIB      = transceiver(IMPORT(*gyro          , get_computed_WBIB));
            ins.grab_computed_WBIB          = transceiver(IMPORT(*gyro          , get_computed_WBIB));
            ins.grab_error_of_computed_WBIB = transceiver(IMPORT(*gyro          , get_error_of_computed_WBIB));
            ins.grab_computed_FSPB          = transceiver(IMPORT(*accelerometer , get_computed_FSPB));
            ins.grab_error_of_computed_FSPB = transceiver(IMPORT(*accelerometer , get_error_of_computed_FSPB));
            // ins.grab_SBII                   = transceiver(IMPORT(dynamics       , get_SBII));
            // ins.grab_VBII                   = transceiver(IMPORT(dynamics       , get_VBII));
            // ins.grab_dbi                    = transceiver(IMPORT(dynamics       , get_dbi));
            // ins.grab_TBI                    = transceiver(IMPORT(dynamics       , get_TBI));
            // ins.grab_SBEE                   = transceiver(IMPORT(dynamics       , get_SBEE));
            // ins.grab_VBEE                   = transceiver(IMPORT(dynamics       , get_VBEE));
            // ins.grab_phibdx                 = transceiver(IMPORT(dynamics       , get_phibdx));
            // ins.grab_thtbdx                 = transceiver(IMPORT(dynamics       , get_thtbdx));
            // ins.grab_psibdx                 = transceiver(IMPORT(dynamics       , get_psibdx));
            ins.grab_gps_update             = transceiver(IMPORT(gps_con        , get_gps_update));
            ins.grab_PHI                    = transceiver(IMPORT(*sdt           , get_PHI));
            ins.grab_DELTA_VEL              = transceiver(IMPORT(*sdt           , get_DELTA_VEL));
            ins.grab_PHI_HIGH               = transceiver(IMPORT(*sdt           , get_PHI_HIGH));
            ins.grab_PHI_LOW                = transceiver(IMPORT(*sdt           , get_PHI_LOW));
            // ins.grab_TEI                    = transceiver(IMPORT(env            , get_TEI));
            gps.grab_transmit_data          = transceiver(IMPORT(gps_con        , get_transmit_data));
            
            /* XXX */
            ins.clear_gps_flag  = [this](){ this->clear_gps = 1; };
            // guidance.set_no_thrust  = [this](){ this->no_thrust = 1; };
            // guidance.set_ltg_thrust = [this](){ this->ltg_thrust = 1; };
        };

        void clear_flag(){
            this->clear_gps = 0;
            // this->no_thrust = 0;
            // this->ltg_thrust = 0;
        }

        int tvc_cmd2egse(struct icf_ctrlblk_t* C) {
            struct can_frame tvc_no1_frame;
            struct can_frame tvc_no2_frame;
            double theta_a_deg, theta_b_deg, theta_c_deg, theta_d_deg;
            double theta_a_rad, theta_b_rad, theta_c_rad, theta_d_rad;
            int16_t theta_a_cnt, theta_b_cnt, theta_c_cnt, theta_d_cnt;
            const double tvc_dsp_resolution = 0.01;
            int ret = 0;

            theta_a_rad = control.get_theta_a_cmd();
            theta_b_rad = control.get_theta_b_cmd();
            theta_c_rad = control.get_theta_c_cmd();
            theta_d_rad = control.get_theta_d_cmd();

            theta_a_deg = theta_a_rad * 180/PI;
            theta_b_deg = theta_b_rad * 180/PI;
            theta_c_deg = theta_c_rad * 180/PI;
            theta_d_deg = theta_d_rad * 180/PI;
            
            theta_a_cnt = theta_a_deg/tvc_dsp_resolution;
            theta_b_cnt = theta_b_deg/tvc_dsp_resolution;
            theta_c_cnt = theta_c_deg/tvc_dsp_resolution;
            theta_d_cnt = theta_d_deg/tvc_dsp_resolution;

            //  fprintf(stderr, "%d %d %d %d\n", theta_a_cnt, theta_c_cnt, theta_b_cnt, theta_d_cnt);
            //  fprintf(stderr, "%f %f %f %f\n", theta_a_rad, theta_c_rad, theta_b_rad, theta_d_rad);
            /*Frame tvc no1*/
            /* Target ID */
            tvc_no1_frame.can_id  = FC2TVC_III_NO1;
            tvc_no1_frame.can_dlc = 8;
            /*  Indicator */
            tvc_no1_frame.data[0] = 0x1;
            /* Task Command */
            tvc_no1_frame.data[1] = TVC_MOVEMENT_FAKE;
            /* TVC no1 Pitch count => Y axis => theta_a*/
            tvc_no1_frame.data[2] = (theta_a_cnt >> 8) & 0xFF;
            tvc_no1_frame.data[3] = (theta_a_cnt & 0xFF);
            /* TVC no1 Yaw count => Z axis => theta_c*/
            tvc_no1_frame.data[4] = (theta_c_cnt >> 8) & 0xFF;
            tvc_no1_frame.data[5] = (theta_c_cnt & 0xFF);

            /*Frame tvc no2*/
            /* Target ID */
            tvc_no2_frame.can_id  = FC2TVC_III_NO2;
            tvc_no2_frame.can_dlc = 8;
            /*  Indicator */
            tvc_no2_frame.data[0] = 0x1;
            /* Task Command */
            tvc_no2_frame.data[1] = TVC_MOVEMENT_FAKE;
            /* TVC no2 Pitch count => Y axis => theta_b*/
            tvc_no2_frame.data[2] = (theta_b_cnt >> 8) & 0xFF;
            tvc_no2_frame.data[3] = (theta_b_cnt & 0xFF);
            /* TVC no2 Yaw count => Z axis => theta_d*/
            tvc_no2_frame.data[4] = (theta_d_cnt >> 8) & 0xFF;
            tvc_no2_frame.data[5] = (theta_d_cnt & 0xFF);
            icf_tx_direct(C, ESPS_TVC_SW_QIDX, (uint8_t *)&tvc_no1_frame, sizeof(struct can_frame));
            icf_tx_direct(C, ESPS_TVC_SW_QIDX, (uint8_t *)&tvc_no2_frame, sizeof(struct can_frame));
            return ret;
        }


        FlightComputer_SimObject() : ins(),
                                     gps()
        {

            ("default_data") clear_flag();
            // ("default_data") guidance.default_data();

            ("initialization") transceiver.initialize_connection("FLIGHT_COMPUTER");
            ("initialization") icf_ctrlblk_init(&icf_esps_ctrl, ICF_SYSTEM_TYPE_ESPS);
            ("initialization") setup_export();
            ("initialization") link();
            ("initialization") gps.initialize(0.05);
            ("initialization") control.initialize();
            ("initialization") ins.initialize();

            P1 (0.001, "scheduled") time->dm_time();
            //  P2 (0.04, "scheduled") icf_rx_ctrl_job(&icf_esps_ctrl, HW_PORT1);
            P2 (0.05, "scheduled") transceiver.receive();

            P2 (0.01, "scheduled") clear_flag();

            P2 (0.05, "scheduled") gps.filter_extrapolation(0.05);
            P2 (0.05, "scheduled") gps.measure(0.05);

            P2 (0.05, "scheduled") ins.update(0.05);
            P2 (0.05, "scheduled") control.control(0.05);
            P2 (0.05, "scheduled") tvc_cmd2egse(&icf_esps_ctrl);
            P2 (0.05, "scheduled") transceiver.transmit();
            ("shutdown") icf_ctrlblk_deinit(&icf_esps_ctrl, ICF_SYSTEM_TYPE_ESPS);

;
        }
};

FlightComputer_SimObject fc;
